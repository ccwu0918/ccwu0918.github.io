<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NquMeta NFT Minting DApp</title>
    
    <!-- 1. è¼‰å…¥å¿…è¦çš„å‡½å¼åº« -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.11.1/ethers.umd.min.js"></script>

    <style>
        /* --- åŸºç¤æ¨£å¼ --- */
        body {
            margin: 0; padding: 0; background-color: #0f172a; color: #e2e8f0;
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            display: flex; justify-content: center; align-items: flex-start;
            min-height: 100vh; padding-top: 50px; padding-bottom: 50px;
        }

        .app-container { width: 100%; max-width: 520px; padding: 20px; }

        .card {
            background: #1e293b; border-radius: 20px; padding: 40px 30px;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.5); border: 1px solid #334155;
            text-align: center; margin-bottom: 20px; position: relative;
            overflow: hidden;
        }

        header h1 {
            margin: 0; background: linear-gradient(to right, #60a5fa, #a78bfa);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            font-size: 2.5rem; font-weight: 800;
        }

        .subtitle { color: #94a3b8; margin-top: 5px; font-size: 0.9rem; }

        /* --- ç‹€æ…‹èˆ‡çµ±è¨ˆ --- */
        .stats-container {
            display: flex; justify-content: space-between; margin: 30px 0;
            background: #0f172a; padding: 15px; border-radius: 12px;
        }
        .stat-box { display: flex; flex-direction: column; }
        .label { font-size: 0.8rem; color: #64748b; text-transform: uppercase; letter-spacing: 1px; }
        .value { font-size: 1.2rem; font-weight: bold; color: #f1f5f9; }

        /* --- æŒ‰éˆ•æ¨£å¼ --- */
        button { cursor: pointer; transition: all 0.2s; font-weight: 600; border: none; }
        
        .connect-btn {
            width: 100%; padding: 15px; background: #3b82f6; color: white;
            border-radius: 12px; font-size: 1rem;
        }
        .connect-btn:hover { background: #2563eb; }

        .mint-btn {
            width: 100%; padding: 16px; background: linear-gradient(135deg, #6366f1, #8b5cf6);
            color: white; border-radius: 12px; font-size: 1.1rem;
            box-shadow: 0 4px 15px rgba(99, 102, 241, 0.4);
        }
        .mint-btn:disabled { background: #475569; box-shadow: none; cursor: wait; }
        .mint-btn:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(99, 102, 241, 0.6); }

        .quantity-selector { display: flex; align-items: center; justify-content: center; gap: 20px; margin-bottom: 20px; }
        .quantity-selector button {
            width: 40px; height: 40px; border-radius: 50%; border: 2px solid #475569;
            background: transparent; color: white; font-size: 1.2rem;
        }
        .quantity-selector button:disabled { opacity: 0.3; cursor: not-allowed; }
        .quantity-selector span { font-size: 1.5rem; font-weight: bold; }

        .status-message { margin-top: 20px; min-height: 24px; font-size: 0.9rem; }
        .error-text { color: #ef4444; }
        .info-text { color: #10b981; }

        /* --- Admin Panel --- */
        .admin-panel {
            background: #312e81; /* æ·±ç´«è‰²èƒŒæ™¯å€éš” */
            border: 1px solid #6366f1;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 25px;
            text-align: left;
        }
        .admin-title { font-size: 0.9rem; color: #a5b4fc; font-weight: bold; margin-bottom: 15px; display: flex; align-items: center; gap: 5px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 10px; }
        
        .admin-controls { display: grid; gap: 15px; }
        
        .admin-row {
            display: flex; align-items: center; justify-content: space-between; gap: 10px;
            background: rgba(0,0,0,0.2); padding: 10px; border-radius: 8px;
        }
        .admin-label { font-size: 0.8rem; color: #cbd5e1; flex: 1; }
        .admin-current { font-size: 0.75rem; color: #94a3b8; margin-right: 5px; display: none; /* Hide current span as value is now in input */ }
        
        .admin-input {
            width: 120px; padding: 6px; border-radius: 4px; border: 1px solid #475569;
            background: #1e293b; color: white; font-size: 0.8rem; text-align: right;
        }
        
        .admin-input-long {
            flex: 2; text-align: left; /* URI è¼¸å…¥æ¡†æ¨£å¼ */
        }
        
        .admin-input-full {
             width: 100%; text-align: left; font-family: monospace; font-size: 0.75rem;
        }

        .admin-btn {
            padding: 6px 12px; border-radius: 6px; font-size: 0.8rem; color: white;
            background: #4f46e5; border: none; white-space: nowrap;
        }
        .admin-btn:hover { background: #4338ca; }
        .admin-btn:disabled { background: #475569; cursor: wait; }

        .toggle-btn {
            width: 100%; padding: 10px; border-radius: 8px; font-size: 0.9rem; color: white;
            background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2);
            display: flex; align-items: center; justify-content: center; margin-bottom: 10px;
        }
        .toggle-btn:hover { background: rgba(255, 255, 255, 0.2); }

        .status-indicator { display: inline-block; width: 8px; height: 8px; border-radius: 50%; margin-right: 8px; }
        .status-on { background-color: #4ade80; box-shadow: 0 0 5px #4ade80; }
        .status-off { background-color: #ef4444; }

        /* --- NFT Grid --- */
        .nft-grid {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 15px; margin-top: 20px;
        }
        .nft-card {
            background: #0f172a; border: 1px solid #334155; border-radius: 12px;
            padding: 10px; text-align: center; transition: transform 0.2s;
            display: flex; flex-direction: column; align-items: center;
            position: relative;
        }
        .nft-card:hover { transform: translateY(-3px); border-color: #6366f1; }
        
        /* åœ–ç‰‡å®¹å™¨ */
        .nft-image-box {
            width: 100%; aspect-ratio: 1; border-radius: 8px; overflow: hidden;
            background: #1e293b; margin-bottom: 10px;
            display: flex; align-items: center; justify-content: center;
            position: relative;
        }
        .nft-image { width: 100%; height: 100%; object-fit: cover; }
        .nft-placeholder { font-size: 2rem; }
        
        .nft-id { font-size: 1rem; font-weight: bold; color: #a78bfa; margin-bottom: 5px; }
        
        .transfer-input {
            width: 90%; padding: 6px; margin-bottom: 6px; border-radius: 4px;
            border: 1px solid #475569; background: #1e293b; color: white; font-size: 0.75rem;
        }
        .transfer-btn {
            width: 100%; padding: 6px; font-size: 0.75rem; background: #ef4444;
            color: white; border-radius: 4px; margin-bottom: 5px;
        }
        .transfer-btn:hover { background: #dc2626; }
        
        .section-title {
            text-align: left; margin-top: 30px; margin-bottom: 15px;
            font-size: 1.2rem; border-bottom: 1px solid #334155; padding-bottom: 10px; color: #f1f5f9;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;
        const ethers = window.ethers;

        // é è¨­åˆç´„åœ°å€
        const DEFAULT_ADDRESS = "0x0FfFF4a1Ef4857047b717419702228DC92FFf09A";

        // âš ï¸ ABI
        const CONTRACT_ABI = [
            // User Functions
            "function mintNquMeta(uint256 tokenQuantity) public payable",
            "function totalSupply() view returns (uint256)",
            "function MAX_SUPPLY() view returns (uint256)",
            "function ownerOf(uint256 tokenId) view returns (address)",
            "function safeTransferFrom(address from, address to, uint256 tokenId)",
            "function tokenURI(uint256 tokenId) view returns (string)",
            "function _isSaleActive() view returns (bool)",
            "function _revealed() view returns (bool)",
            // Config Getters
            "function mintPrice() view returns (uint256)",
            "function maxBalance() view returns (uint256)",
            "function maxMint() view returns (uint256)",
            "function notRevealedUri() view returns (string)", 
            "function baseURI() view returns (string)",        // ç”¨æˆ¶ç¢ºèªåˆç´„ä¸­å·²æœ‰ public baseURI
            // Admin Functions
            "function owner() view returns (address)",
            "function flipSaleActive() public",
            "function flipReveal() public",
            "function setMintPrice(uint256 _mintPrice) public",
            "function setMaxBalance(uint256 _maxBalance) public",
            "function setMaxMint(uint256 _maxMint) public",
            "function setNotRevealedURI(string memory _notRevealedURI) public",
            "function setBaseURI(string memory _newBaseURI) public"
        ];

        function App() {
            // Contract Address State
            const [targetContractAddress, setTargetContractAddress] = useState(DEFAULT_ADDRESS);
            
            const [account, setAccount] = useState(null);
            const [isOwner, setIsOwner] = useState(false);
            const [isConnecting, setIsConnecting] = useState(false);
            const [isMinting, setIsMinting] = useState(false);
            
            const [supply, setSupply] = useState(0);
            const [quantity, setQuantity] = useState(1);
            const [isSaleActive, setIsSaleActive] = useState(false);
            const [isRevealed, setIsRevealed] = useState(false);
            
            // Display Values
            const [currentMintPrice, setCurrentMintPrice] = useState("0");

            // Admin Input State (Auto-filled)
            const [newMintPrice, setNewMintPrice] = useState("");
            const [newMaxBalance, setNewMaxBalance] = useState("");
            const [newMaxMint, setNewMaxMint] = useState("");
            const [newNotRevealedURI, setNewNotRevealedURI] = useState("");
            const [newBaseURI, setNewBaseURI] = useState("");
            const [inputAddress, setInputAddress] = useState(DEFAULT_ADDRESS); // UI input for address
            
            const [status, setStatus] = useState("");
            const [error, setError] = useState("");
            const [userNFTs, setUserNFTs] = useState([]);
            const [transferringId, setTransferringId] = useState(null);
            const [isAdminAction, setIsAdminAction] = useState(false);

            const accountRef = useRef(account);
            accountRef.current = account;
            
            // Ref for address to be used in interval
            const contractAddressRef = useRef(targetContractAddress);
            contractAddressRef.current = targetContractAddress;

            useEffect(() => {
                checkIfWalletIsConnected();
                if (window.ethereum) {
                    window.ethereum.on('accountsChanged', handleAccountsChanged);
                }
                
                const intervalId = setInterval(() => {
                    if (accountRef.current) {
                        fetchContractData(accountRef.current, contractAddressRef.current, true); 
                    }
                }, 30000);

                return () => {
                    if (window.ethereum) {
                        window.ethereum.removeListener('accountsChanged', handleAccountsChanged);
                    }
                    clearInterval(intervalId);
                };
            }, []);

            const handleAccountsChanged = (accounts) => {
                if (accounts.length > 0) {
                    setAccount(accounts[0]);
                    fetchContractData(accounts[0], targetContractAddress);
                } else {
                    setAccount(null);
                    setIsOwner(false);
                    setStatus("è«‹é€£æ¥éŒ¢åŒ…");
                    setUserNFTs([]);
                }
            };

            const checkIfWalletIsConnected = async () => {
                if (window.location.protocol === 'file:') return;
                if (window.ethereum) {
                    try {
                        const provider = new ethers.BrowserProvider(window.ethereum);
                        const accounts = await provider.listAccounts();
                        if (accounts.length > 0) {
                            setAccount(accounts[0].address);
                            fetchContractData(accounts[0].address, targetContractAddress);
                        }
                    } catch (err) {
                        console.error(err);
                    }
                }
            };

            const connectWallet = async () => {
                if (window.location.protocol === 'file:') return setError("âš ï¸ è«‹ä½¿ç”¨ Local Server åŸ·è¡Œã€‚");
                if (typeof window.ethereum === 'undefined') return setError("æœªåµæ¸¬åˆ° MetaMaskã€‚");
                setIsConnecting(true);
                try {
                    const provider = new ethers.BrowserProvider(window.ethereum);
                    const accounts = await provider.send("eth_requestAccounts", []);
                    if (accounts && accounts.length > 0) {
                        setAccount(accounts[0]);
                        setError("");
                        setStatus("éŒ¢åŒ…é€£æ¥æˆåŠŸ ğŸŸ¢");
                        await fetchContractData(accounts[0], targetContractAddress);
                    }
                } catch (err) {
                    console.error(err);
                    setError("é€£æ¥å¤±æ•—");
                } finally {
                    setIsConnecting(false);
                }
            };
            
            // Update Contract Address Handler
            const handleUpdateContractAddress = () => {
                if(!ethers.isAddress(inputAddress)) return alert("ç„¡æ•ˆçš„åˆç´„åœ°å€");
                setTargetContractAddress(inputAddress);
                setStatus(`åˆç´„åœ°å€å·²æ›´æ–°ï¼Œé‡æ–°è®€å–ä¸­...`);
                // Clear previous data
                setSupply(0);
                setIsOwner(false);
                setUserNFTs([]);
                // Fetch new data
                if(account) {
                    fetchContractData(account, inputAddress);
                }
            };

            const fetchContractData = async (currentAccount, addressToFetch, isBackground = false) => {
                if (!window.ethereum || !addressToFetch) return;
                try {
                    const provider = new ethers.BrowserProvider(window.ethereum);
                    const contract = new ethers.Contract(addressToFetch, CONTRACT_ABI, provider);

                    // 1. Basic Stats
                    const total = await contract.totalSupply();
                    const saleActive = await contract._isSaleActive();
                    const revealed = await contract._revealed();
                    const contractOwner = await contract.owner();
                    
                    // 2. Configs
                    const price = await contract.mintPrice();
                    const balanceLimit = await contract.maxBalance();
                    const mintLimit = await contract.maxMint();

                    // 3. Update States
                    setSupply(total.toString());
                    setIsSaleActive(saleActive);
                    setIsRevealed(revealed);
                    
                    const priceInEther = ethers.formatEther(price);
                    setCurrentMintPrice(priceInEther);

                    // Auto-fill inputs if they are empty or just update them to current state (Sync)
                    if (!isBackground) {
                        setNewMintPrice(priceInEther);
                        setNewMaxBalance(balanceLimit.toString());
                        setNewMaxMint(mintLimit.toString());

                        // Fetch URIs (Try/Catch in case contract doesn't expose getters)
                        try {
                            const notRev = await contract.notRevealedUri();
                            setNewNotRevealedURI(notRev);
                        } catch (e) { console.log("Fetch notRevealedUri failed", e); }

                        try {
                            const base = await contract.baseURI(); 
                            setNewBaseURI(base);
                        } catch (e) { console.log("Fetch baseURI failed", e); }
                    }

                    if (currentAccount && contractOwner.toLowerCase() === currentAccount.toLowerCase()) {
                        setIsOwner(true);
                    } else {
                        setIsOwner(false);
                    }

                    // Status Messages
                    if (!isBackground) {
                         if (!saleActive) setStatus("âš ï¸ è²©å”®æš«åœä¸­ (Paused)");
                         else setStatus("ğŸŸ¢ è²©å”®é€²è¡Œä¸­ (Active)");
                    } else {
                        if (!saleActive) setStatus("âš ï¸ è²©å”®æš«åœä¸­ (Paused)");
                        else if (status.includes("æš«åœ")) setStatus("ğŸŸ¢ è²©å”®é€²è¡Œä¸­ (Active)"); 
                    }

                    if (currentAccount) {
                        const ownedIds = [];
                        const maxSupply = 10;
                        for (let i = 1; i <= maxSupply; i++) {
                            try {
                                const owner = await contract.ownerOf(i);
                                if (owner.toLowerCase() === currentAccount.toLowerCase()) {
                                    ownedIds.push(i);
                                }
                            } catch (e) {}
                        }
                        setUserNFTs(ownedIds);
                    }

                } catch (err) {
                    console.error("æ•¸æ“šè®€å–éŒ¯èª¤:", err);
                    if(!isBackground) setStatus("ç„¡æ³•è®€å–åˆç´„æ•¸æ“š (è«‹æª¢æŸ¥åœ°å€)");
                }
            };

            const toggleSale = async () => {
                if (!isOwner) return;
                setIsAdminAction(true);
                try {
                    const provider = new ethers.BrowserProvider(window.ethereum);
                    const signer = await provider.getSigner();
                    const contract = new ethers.Contract(targetContractAddress, CONTRACT_ABI, signer);
                    const tx = await contract.flipSaleActive();
                    setStatus("æ­£åœ¨åˆ‡æ›è²©å”®ç‹€æ…‹...");
                    await tx.wait();
                    setStatus("âœ… è²©å”®ç‹€æ…‹å·²æ›´æ–°");
                    fetchContractData(account, targetContractAddress);
                } catch (err) {
                    console.error(err);
                    alert("æ“ä½œå¤±æ•—");
                } finally { setIsAdminAction(false); }
            };

            const toggleReveal = async () => {
                if (!isOwner) return;
                if (!confirm("ç¢ºå®šè¦é–‹å•Ÿç›²ç›’å—ï¼Ÿé€™æ˜¯ä¸€å€‹å…¨åŸŸè¨­å®šï¼Œæ‰€æœ‰ NFT éƒ½å°‡è¢«æ­ç¤ºã€‚")) return;
                
                setIsAdminAction(true);
                try {
                    const provider = new ethers.BrowserProvider(window.ethereum);
                    const signer = await provider.getSigner();
                    const contract = new ethers.Contract(targetContractAddress, CONTRACT_ABI, signer);
                    const tx = await contract.flipReveal();
                    setStatus("æ­£åœ¨é–‹å•Ÿç›²ç›’...");
                    await tx.wait();
                    setStatus("âœ… ç›²ç›’å·²é–‹å•Ÿï¼");
                    fetchContractData(account, targetContractAddress);
                } catch (err) {
                    console.error(err);
                    alert("æ“ä½œå¤±æ•—");
                } finally { setIsAdminAction(false); }
            };

            // --- Admin Config Updates ---
            const handleUpdatePrice = async () => {
                if (!newMintPrice) return alert("è«‹è¼¸å…¥åƒ¹æ ¼");
                setIsAdminAction(true);
                try {
                    const provider = new ethers.BrowserProvider(window.ethereum);
                    const signer = await provider.getSigner();
                    const contract = new ethers.Contract(targetContractAddress, CONTRACT_ABI, signer);
                    const priceInWei = ethers.parseEther(newMintPrice);
                    const tx = await contract.setMintPrice(priceInWei);
                    setStatus("æ›´æ–°åƒ¹æ ¼ä¸­...");
                    await tx.wait();
                    setStatus("âœ… åƒ¹æ ¼å·²æ›´æ–°");
                    fetchContractData(account, targetContractAddress);
                } catch (err) { alert("æ›´æ–°å¤±æ•—"); } finally { setIsAdminAction(false); }
            };

            const handleUpdateMaxBalance = async () => {
                if (!newMaxBalance) return alert("è«‹è¼¸å…¥æ•¸é‡");
                setIsAdminAction(true);
                try {
                    const provider = new ethers.BrowserProvider(window.ethereum);
                    const signer = await provider.getSigner();
                    const contract = new ethers.Contract(targetContractAddress, CONTRACT_ABI, signer);
                    const tx = await contract.setMaxBalance(newMaxBalance);
                    setStatus("æ›´æ–°é™è³¼é‡ä¸­...");
                    await tx.wait();
                    setStatus("âœ… é™è³¼é‡å·²æ›´æ–°");
                    fetchContractData(account, targetContractAddress);
                } catch (err) { alert("æ›´æ–°å¤±æ•—"); } finally { setIsAdminAction(false); }
            };

            const handleUpdateMaxMint = async () => {
                if (!newMaxMint) return alert("è«‹è¼¸å…¥æ•¸é‡");
                setIsAdminAction(true);
                try {
                    const provider = new ethers.BrowserProvider(window.ethereum);
                    const signer = await provider.getSigner();
                    const contract = new ethers.Contract(targetContractAddress, CONTRACT_ABI, signer);
                    const tx = await contract.setMaxMint(newMaxMint);
                    setStatus("æ›´æ–°å–®æ¬¡é™åˆ¶ä¸­...");
                    await tx.wait();
                    setStatus("âœ… å–®æ¬¡é™åˆ¶å·²æ›´æ–°");
                    fetchContractData(account, targetContractAddress);
                } catch (err) { alert("æ›´æ–°å¤±æ•—"); } finally { setIsAdminAction(false); }
            };

            const handleUpdateNotRevealedURI = async () => {
                if (!newNotRevealedURI) return alert("è«‹è¼¸å…¥ URI");
                setIsAdminAction(true);
                try {
                    const provider = new ethers.BrowserProvider(window.ethereum);
                    const signer = await provider.getSigner();
                    const contract = new ethers.Contract(targetContractAddress, CONTRACT_ABI, signer);
                    const tx = await contract.setNotRevealedURI(newNotRevealedURI);
                    setStatus("æ›´æ–°ç›²ç›’åœ–ç‰‡ä¸­...");
                    await tx.wait();
                    setStatus("âœ… ç›²ç›’åœ–ç‰‡å·²æ›´æ–°");
                    fetchContractData(account, targetContractAddress);
                } catch (err) { console.error(err); alert("æ›´æ–°å¤±æ•—"); } finally { setIsAdminAction(false); }
            };

            const handleUpdateBaseURI = async () => {
                if (!newBaseURI) return alert("è«‹è¼¸å…¥ URI");
                setIsAdminAction(true);
                try {
                    const provider = new ethers.BrowserProvider(window.ethereum);
                    const signer = await provider.getSigner();
                    const contract = new ethers.Contract(targetContractAddress, CONTRACT_ABI, signer);
                    const tx = await contract.setBaseURI(newBaseURI);
                    setStatus("æ›´æ–° Base URI ä¸­...");
                    await tx.wait();
                    setStatus("âœ… Base URI å·²æ›´æ–°");
                    fetchContractData(account, targetContractAddress);
                } catch (err) { console.error(err); alert("æ›´æ–°å¤±æ•—"); } finally { setIsAdminAction(false); }
            };

            const mintNFT = async () => {
                if (!account) return;
                setIsMinting(true);
                setError("");
                setStatus("ç­‰å¾…ç¢ºèªä¸­... ğŸ¦Š");
                try {
                    const provider = new ethers.BrowserProvider(window.ethereum);
                    const signer = await provider.getSigner();
                    const contract = new ethers.Contract(targetContractAddress, CONTRACT_ABI, signer);
                    
                    const priceInWei = ethers.parseEther(currentMintPrice); 
                    const totalPrice = priceInWei * BigInt(quantity);
                    
                    const tx = await contract.mintNquMeta(quantity, { value: totalPrice });
                    setStatus("äº¤æ˜“ç™¼é€æˆåŠŸï¼å€å¡Šç¢ºèªä¸­... ğŸ§±");
                    await tx.wait(1);
                    setStatus(`ğŸ‰ é‘„é€ æˆåŠŸï¼`);
                    fetchContractData(account, targetContractAddress);
                } catch (err) {
                    console.error(err);
                    setError(err.reason ? `åˆç´„éŒ¯èª¤: ${err.reason}` : "äº¤æ˜“å¤±æ•—");
                } finally { setIsMinting(false); }
            };

            const handleTransfer = async (tokenId, toAddress) => {
                if (!ethers.isAddress(toAddress)) return alert("ç„¡æ•ˆåœ°å€");
                if (!confirm(`ç¢ºå®šè½‰é€ #${tokenId} çµ¦ ${toAddress}?`)) return;
                setTransferringId(tokenId);
                try {
                    const provider = new ethers.BrowserProvider(window.ethereum);
                    const signer = await provider.getSigner();
                    const contract = new ethers.Contract(targetContractAddress, CONTRACT_ABI, signer);
                    const tx = await contract.safeTransferFrom(account, toAddress, tokenId);
                    setStatus("è½‰é€ä¸­...");
                    await tx.wait();
                    setStatus(`âœ… #${tokenId} è½‰é€æˆåŠŸ`);
                    fetchContractData(account, targetContractAddress);
                } catch (err) {
                    alert("è½‰é€å¤±æ•—");
                } finally { setTransferringId(null); }
            };

            return (
                <div className="app-container">
                    <div className="card">
                        <header>
                            <h1>ğŸ’ NquMeta NFT</h1>
                            <p className="subtitle">ERC721A Gas Optimized Collection</p>
                        </header>

                        {/* --- Admin Panel --- */}
                        {account && isOwner && (
                            <div className="admin-panel">
                                <div className="admin-title">ğŸ”´ ç®¡ç†å“¡æ§åˆ¶å° (Admin Dashboard)</div>
                                
                                {/* Contract Address Config */}
                                <div style={{marginBottom: "20px", paddingBottom: "15px", borderBottom: "1px solid rgba(255,255,255,0.1)"}}>
                                    <div className="admin-label" style={{marginBottom: "5px"}}>NFT åˆç´„åœ°å€</div>
                                    <div style={{display: "flex", gap: "10px"}}>
                                        <input 
                                            className="admin-input admin-input-full" 
                                            value={inputAddress} 
                                            onChange={(e) => setInputAddress(e.target.value)}
                                            placeholder="0x..."
                                        />
                                        <button className="admin-btn" onClick={handleUpdateContractAddress} disabled={isAdminAction}>æ›´æ–°åœ°å€</button>
                                    </div>
                                </div>
                                
                                <button className="toggle-btn" onClick={toggleSale} disabled={isAdminAction}>
                                    <span className={`status-indicator ${isSaleActive ? 'status-on' : 'status-off'}`}></span>
                                    {isSaleActive ? "é—œé–‰è²©å”® (Pause Sale)" : "é–‹å•Ÿè²©å”® (Start Sale)"}
                                </button>
                                
                                <button className="toggle-btn" onClick={toggleReveal} disabled={isAdminAction}>
                                    <span className={`status-indicator ${isRevealed ? 'status-on' : 'status-off'}`}></span>
                                    {isRevealed ? "éš±è—ç›²ç›’ (Hide Reveal)" : "é–‹å•Ÿç›²ç›’ (Reveal All)"}
                                </button>

                                <div className="admin-controls">
                                    {/* 1. Mint Price */}
                                    <div className="admin-row">
                                        <div className="admin-label">é‘„é€ åƒ¹æ ¼ (ETH)</div>
                                        <input 
                                            className="admin-input" placeholder="0.001" 
                                            value={newMintPrice} onChange={(e) => setNewMintPrice(e.target.value)}
                                        />
                                        <button className="admin-btn" onClick={handleUpdatePrice} disabled={isAdminAction}>æ›´æ–°</button>
                                    </div>

                                    {/* 2. Max Balance */}
                                    <div className="admin-row">
                                        <div className="admin-label">éŒ¢åŒ…é™è³¼ (Max Balance)</div>
                                        <input 
                                            className="admin-input" type="number" placeholder="5" 
                                            value={newMaxBalance} onChange={(e) => setNewMaxBalance(e.target.value)}
                                        />
                                        <button className="admin-btn" onClick={handleUpdateMaxBalance} disabled={isAdminAction}>æ›´æ–°</button>
                                    </div>

                                    {/* 3. Max Mint */}
                                    <div className="admin-row">
                                        <div className="admin-label">å–®æ¬¡é™è³¼ (Max Mint)</div>
                                        <input 
                                            className="admin-input" type="number" placeholder="3" 
                                            value={newMaxMint} onChange={(e) => setNewMaxMint(e.target.value)}
                                        />
                                        <button className="admin-btn" onClick={handleUpdateMaxMint} disabled={isAdminAction}>æ›´æ–°</button>
                                    </div>

                                    {/* 4. Not Revealed URI */}
                                    <div className="admin-row">
                                        <div className="admin-label">ç›²ç›’å°é¢åœ–ç‰‡ (Not Revealed URI)</div>
                                        <input 
                                            className="admin-input admin-input-long" placeholder="ipfs://..." 
                                            value={newNotRevealedURI} onChange={(e) => setNewNotRevealedURI(e.target.value)}
                                        />
                                        <button className="admin-btn" onClick={handleUpdateNotRevealedURI} disabled={isAdminAction}>æ›´æ–°</button>
                                    </div>

                                    {/* 5. Base URI */}
                                    <div className="admin-row">
                                        <div className="admin-label">ç›²ç›’åœ–ç‰‡è·¯å¾‘ (Base URI)</div>
                                        <input 
                                            className="admin-input admin-input-long" placeholder="ipfs://..." 
                                            value={newBaseURI} onChange={(e) => setNewBaseURI(e.target.value)}
                                        />
                                        <button className="admin-btn" onClick={handleUpdateBaseURI} disabled={isAdminAction}>æ›´æ–°</button>
                                    </div>
                                </div>
                            </div>
                        )}

                        <div className="stats-container">
                            <div className="stat-box">
                                <span className="label">å·²é‘„é€ </span>
                                <span className="value">{supply} / 10</span>
                            </div>
                            <div className="stat-box">
                                <span className="label">åƒ¹æ ¼</span>
                                <span className="value">{currentMintPrice} ETH</span>
                            </div>
                        </div>

                        {!account ? (
                            <button className="connect-btn" onClick={connectWallet} disabled={isConnecting}>
                                {isConnecting ? "é€£æ¥ä¸­..." : "é€£æ¥éŒ¢åŒ…"}
                            </button>
                        ) : (
                            <div>
                                <div className="quantity-selector">
                                    <button onClick={() => setQuantity(Math.max(1, quantity - 1))} disabled={isMinting}>-</button>
                                    <span>{quantity}</span>
                                    <button onClick={() => setQuantity(Math.min(parseInt(currentMaxMint) || 5, quantity + 1))} disabled={isMinting}>+</button>
                                </div>
                                <button className="mint-btn" onClick={mintNFT} disabled={isMinting || !isSaleActive}>
                                    {isMinting ? "é‘„é€ ä¸­..." : (isSaleActive ? `ç«‹å³é‘„é€  ${quantity} å€‹` : "ç›®å‰ç„¡æ³•é‘„é€ ")}
                                </button>

                                {userNFTs.length > 0 && (
                                    <div>
                                        <h3 className="section-title">ğŸ–¼ï¸ æˆ‘çš„æ”¶è— ({userNFTs.length})</h3>
                                        <div className="nft-grid">
                                            {userNFTs.map(id => (
                                                <NFTCard 
                                                    key={id} 
                                                    tokenId={id} 
                                                    onTransfer={handleTransfer} 
                                                    isTransferring={transferringId === id}
                                                    isRevealed={isRevealed}
                                                    contractAddress={targetContractAddress}
                                                />
                                            ))}
                                        </div>
                                    </div>
                                )}
                            </div>
                        )}

                        <div className="status-message">
                            {error && <p className="error-text">{error}</p>}
                            {status && <p className="info-text">{status}</p>}
                        </div>
                    </div>
                </div>
            );
        }

        // --- å­å…ƒä»¶ï¼šNFT å¡ç‰‡ ---
        function NFTCard({ tokenId, onTransfer, isTransferring, isRevealed, contractAddress }) {
            const [toAddress, setToAddress] = useState("");
            const [metaImage, setMetaImage] = useState(null);
            const [loadingMeta, setLoadingMeta] = useState(false);

            useEffect(() => {
                fetchMetadata();
            }, [isRevealed, tokenId, contractAddress]);

            const fetchMetadata = async () => {
                setLoadingMeta(true);
                try {
                    const provider = new ethers.BrowserProvider(window.ethereum);
                    const contract = new ethers.Contract(contractAddress, CONTRACT_ABI, provider);
                    
                    const uri = await contract.tokenURI(tokenId);
                    
                    if (uri) {
                        let httpUri = uri;
                        if (uri.startsWith("ipfs://")) {
                            httpUri = uri.replace("ipfs://", "https://ipfs.io/ipfs/");
                        }

                        const response = await fetch(httpUri);
                        const metadata = await response.json();
                        
                        if (metadata.image) {
                            let imgUrl = metadata.image;
                            if (imgUrl.startsWith("ipfs://")) {
                                imgUrl = imgUrl.replace("ipfs://", "https://ipfs.io/ipfs/");
                            }
                            setMetaImage(imgUrl);
                        }
                    }
                } catch (err) {
                    console.error("Metadata error:", err);
                    setMetaImage(null);
                } finally {
                    setLoadingMeta(false);
                }
            };

            return (
                <div className="nft-card">
                    <div className="nft-image-box">
                        {loadingMeta ? (
                            <span style={{fontSize: "0.8rem", color: "#64748b"}}>Loading...</span>
                        ) : (
                            metaImage ? (
                                <img 
                                    src={metaImage} 
                                    className="nft-image" 
                                    alt={`NFT #${tokenId}`}
                                    onError={(e) => {e.target.style.display='none';}} 
                                />
                            ) : (
                                <span className="nft-placeholder">{isRevealed ? "ğŸ–¼ï¸" : "ğŸ"}</span>
                            )
                        )}
                    </div>
                    
                    <span className="nft-id">#{tokenId}</span>
                    <span style={{fontSize: "0.75rem", color: "#64748b", marginBottom: "8px"}}>
                        {isRevealed ? "å·²é–‹å•Ÿ" : "æœªé–‹å•Ÿ"}
                    </span>
                    
                    <input 
                        type="text" placeholder="æ¥æ”¶åœ°å€ 0x..." className="transfer-input"
                        value={toAddress} onChange={(e) => setToAddress(e.target.value)}
                        disabled={isTransferring}
                        style={{marginTop: "5px"}}
                    />
                    <button 
                        className="transfer-btn"
                        disabled={isTransferring || !toAddress}
                        onClick={() => onTransfer(tokenId, toAddress)}
                    >
                        {isTransferring ? "..." : "è½‰è´ˆ"}
                    </button>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>