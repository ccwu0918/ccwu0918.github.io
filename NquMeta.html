<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ’NQU Meta - ç›²ç›’ NFT é‘„é€ å¹³å° NFT Minting DApp</title>
    
    <!-- 1. è¼‰å…¥å¿…è¦çš„å‡½å¼åº« -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.11.1/ethers.umd.min.js"></script>
    <!-- Markdown è§£æå™¨ -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <style>
        /* --- åŸºç¤æ¨£å¼ --- */
        body {
            margin: 0; padding: 0; background-color: #0f172a; color: #e2e8f0;
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            display: flex; justify-content: center; align-items: flex-start;
            min-height: 100vh; padding-top: 50px; padding-bottom: 50px;
        }

        .app-container { width: 100%; max-width: 520px; padding: 20px; }

        .card {
            background: #1e293b; border-radius: 20px; padding: 40px 30px;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.5); border: 1px solid #334155;
            text-align: center; margin-bottom: 20px; position: relative;
            overflow: hidden;
        }

        header h1 {
            margin: 0; background: linear-gradient(to right, #60a5fa, #a78bfa);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            font-size: 2.0rem; font-weight: 800;
        }

        .subtitle { color: #94a3b8; margin-top: 5px; font-size: 0.9rem; }

        /* --- API Key Input --- */
        .api-key-section {
            background: rgba(15, 23, 42, 0.6); padding: 15px; border-radius: 12px;
            margin: 20px 0; border: 1px dashed #475569; text-align: left;
        }
        .api-key-label { font-size: 0.8rem; color: #94a3b8; margin-bottom: 8px; display: block; font-weight: 600; }
        .api-key-input {
            width: 100%; padding: 10px; border-radius: 6px; border: 1px solid #475569;
            background: #0f172a; color: white; font-family: monospace; box-sizing: border-box;
        }
        .api-key-input:focus { border-color: #a855f7; outline: none; }

        /* --- éŒ¢åŒ…è³‡è¨Šåˆ— --- */
        .wallet-info-container {
            display: flex; justify-content: center; gap: 8px; margin: 25px 0 10px 0;
            flex-wrap: wrap; align-items: center;
        }

        .wallet-badge {
            padding: 6px 12px; border-radius: 20px; font-size: 0.85rem; font-weight: 600;
            display: flex; align-items: center; gap: 6px;
        }

        .badge-status { background-color: #f8fafc; color: #0f172a; }
        .badge-chain { background-color: #3b82f6; color: white; }
        .badge-address { background-color: #334155; color: #e2e8f0; font-family: monospace; }
        .badge-disconnect {
            background-color: #ef4444; color: white; cursor: pointer;
            transition: background-color 0.2s;
        }
        .badge-disconnect:hover { background-color: #dc2626; }
        .connection-dot { width: 8px; height: 8px; background-color: #4ade80; border-radius: 50%; }

        /* --- ç‹€æ…‹èˆ‡çµ±è¨ˆ --- */
        .stats-container {
            display: flex; justify-content: space-between; margin: 20px 0 30px 0;
            background: #0f172a; padding: 15px; border-radius: 12px;
        }
        .stat-box { display: flex; flex-direction: column; }
        .label { font-size: 0.8rem; color: #64748b; text-transform: uppercase; letter-spacing: 1px; }
        .value { font-size: 1.2rem; font-weight: bold; color: #f1f5f9; }

        /* --- æŒ‰éˆ•æ¨£å¼ --- */
        button { cursor: pointer; transition: all 0.2s; font-weight: 600; border: none; }
        
        .connect-btn {
            width: 100%; padding: 15px; background: #3b82f6; color: white;
            border-radius: 12px; font-size: 1rem;
        }
        .connect-btn:hover { background: #2563eb; }

        .mint-btn {
            width: 100%; padding: 16px; background: linear-gradient(135deg, #6366f1, #8b5cf6);
            color: white; border-radius: 12px; font-size: 1.1rem;
            box-shadow: 0 4px 15px rgba(99, 102, 241, 0.4);
        }
        .mint-btn:disabled { background: #475569; box-shadow: none; cursor: wait; }
        .mint-btn:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(99, 102, 241, 0.6); }

        .quantity-selector { display: flex; align-items: center; justify-content: center; gap: 20px; margin-bottom: 20px; }
        .quantity-selector button {
            width: 40px; height: 40px; border-radius: 50%; border: 2px solid #475569;
            background: transparent; color: white; font-size: 1.2rem;
        }
        .quantity-selector button:disabled { opacity: 0.3; cursor: not-allowed; }
        .quantity-selector span { font-size: 1.5rem; font-weight: bold; }

        .status-message { margin-top: 20px; min-height: 24px; font-size: 0.9rem; }
        .error-text { color: #ef4444; }
        .info-text { color: #10b981; }

        /* --- Admin Panel --- */
        .admin-panel {
            background: #312e81; border: 1px solid #6366f1; border-radius: 12px;
            padding: 15px; margin-bottom: 25px; text-align: left;
        }
        .admin-title { font-size: 0.9rem; color: #a5b4fc; font-weight: bold; margin-bottom: 15px; display: flex; align-items: center; gap: 5px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 10px; }
        
        .admin-controls { display: grid; gap: 15px; }
        .admin-row {
            display: flex; align-items: center; justify-content: space-between; gap: 10px;
            background: rgba(0,0,0,0.2); padding: 10px; border-radius: 8px;
        }
        .admin-label { font-size: 0.8rem; color: #cbd5e1; flex: 1; }
        .admin-input {
            width: 120px; padding: 6px; border-radius: 4px; border: 1px solid #475569;
            background: #1e293b; color: white; font-size: 0.8rem; text-align: right;
        }
        .admin-input-long { flex: 2; text-align: left; }
        .admin-input-full { width: 100%; text-align: left; font-family: monospace; font-size: 0.75rem; }
        .admin-btn {
            padding: 6px 12px; border-radius: 6px; font-size: 0.8rem; color: white;
            background: #4f46e5; border: none; white-space: nowrap;
        }
        .admin-btn:hover { background: #4338ca; }
        .admin-btn:disabled { background: #475569; cursor: wait; }

        .toggle-btn {
            width: 100%; padding: 10px; border-radius: 8px; font-size: 0.9rem; color: white;
            background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2);
            display: flex; align-items: center; justify-content: center; margin-bottom: 10px;
        }
        .toggle-btn:hover { background: rgba(255, 255, 255, 0.2); }
        .status-indicator { display: inline-block; width: 8px; height: 8px; border-radius: 50%; margin-right: 8px; }
        .status-on { background-color: #4ade80; box-shadow: 0 0 5px #4ade80; }
        .status-off { background-color: #ef4444; }

        /* --- AI Feature Styles --- */
        .ai-btn {
            background: linear-gradient(135deg, #a855f7, #d946ef);
            color: white; border: none; padding: 8px 12px; border-radius: 8px;
            font-size: 0.85rem; width: 100%; margin-top: 10px;
            display: flex; align-items: center; justify-content: center; gap: 5px;
        }
        .ai-btn:hover { opacity: 0.9; transform: scale(1.02); }
        .ai-btn:disabled { background: #475569; transform: none; cursor: wait; }
        
        .ai-result-box {
            background: #0f172a; padding: 12px; border-radius: 8px; margin-top: 10px;
            border: 1px solid #a855f7; font-size: 0.85rem; line-height: 1.5; text-align: left;
            max-height: 300px; overflow-y: auto; color: #e2e8f0;
        }
        .ai-result-box img { max-width: 100%; border-radius: 8px; }
        .ai-result-box p { margin-bottom: 8px; }

        /* --- NFT Grid --- */
        .nft-grid {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 15px; margin-top: 20px;
        }
        .nft-card {
            background: #0f172a; border: 1px solid #334155; border-radius: 12px;
            padding: 10px; text-align: center; transition: transform 0.2s;
            display: flex; flex-direction: column; align-items: center;
            position: relative;
        }
        .nft-card:hover { transform: translateY(-3px); border-color: #6366f1; }
        
        .nft-image-box {
            width: 100%; aspect-ratio: 1; border-radius: 8px; overflow: hidden;
            background: #1e293b; margin-bottom: 10px;
            display: flex; align-items: center; justify-content: center;
            position: relative;
        }
        .nft-image { width: 100%; height: 100%; object-fit: cover; }
        .nft-placeholder { font-size: 2rem; }
        .nft-id { font-size: 1rem; font-weight: bold; color: #a78bfa; margin-bottom: 5px; }
        
        .transfer-input {
            width: 90%; padding: 6px; margin-bottom: 6px; border-radius: 4px;
            border: 1px solid #475569; background: #1e293b; color: white; font-size: 0.75rem;
        }
        .transfer-btn {
            width: 100%; padding: 6px; font-size: 0.75rem; background: #ef4444;
            color: white; border-radius: 4px; margin-bottom: 5px;
        }
        .transfer-btn:hover { background: #dc2626; }
        
        .section-title {
            text-align: left; margin-top: 30px; margin-bottom: 15px;
            font-size: 1.2rem; border-bottom: 1px solid #334155; padding-bottom: 10px; color: #f1f5f9;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;
        const ethers = window.ethers;

        // Gemini API Key (Inject from environment)
        const DEFAULT_API_KEY = "AIza**********************************t5Vs"; 

        // é è¨­åˆç´„åœ°å€
        const DEFAULT_ADDRESS = "0xB2061d8eDc4D6792Be6aed586034CeAa54D9A3eF";

        // âš ï¸ ABI
        const CONTRACT_ABI = [
            "function mintNquMeta(uint256 tokenQuantity) public payable",
            "function totalSupply() view returns (uint256)",
            "function MAX_SUPPLY() view returns (uint256)",
            "function ownerOf(uint256 tokenId) view returns (address)",
            "function safeTransferFrom(address from, address to, uint256 tokenId)",
            "function tokenURI(uint256 tokenId) view returns (string)",
            "function _isSaleActive() view returns (bool)",
            "function _revealed() view returns (bool)",
            "function mintPrice() view returns (uint256)",
            "function maxBalance() view returns (uint256)",
            "function maxMint() view returns (uint256)",
            "function notRevealedUri() view returns (string)", 
            "function baseURI() view returns (string)",
            "function owner() view returns (address)",
            "function flipSaleActive() public",
            "function flipReveal() public",
            "function setMintPrice(uint256 _mintPrice) public",
            "function setMaxBalance(uint256 _maxBalance) public",
            "function setMaxMint(uint256 _maxMint) public",
            "function setNotRevealedURI(string memory _notRevealedURI) public",
            "function setBaseURI(string memory _newBaseURI) public"
        ];

        // --- Gemini AI (Text) Helper Function ---
        async function callGeminiAPI(apiKey, prompt) {
            if (!apiKey) return "âš ï¸ è«‹å…ˆè¨­å®š API Key";
            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
            
            try {
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                });
                
                if (!response.ok) {
                    const errText = await response.text();
                    throw new Error(`API Error: ${response.status} - ${errText}`);
                }
                const data = await response.json();
                return data.candidates?.[0]?.content?.parts?.[0]?.text || "No response generated.";
            } catch (error) {
                console.error("Gemini AI Error:", error);
                return `âŒ ç”Ÿæˆå¤±æ•—: ${error.message}`;
            }
        }

        // --- Imagen AI (Image) Helper Function ---
        async function callImagenAPI(apiKey, prompt) {
            if (!apiKey) return { success: false, error: "âš ï¸ è«‹å…ˆè¨­å®š API Key" };
            // æ›´æ–°ç‚ºæ”¯æ´çš„ imagen-4.0 æ¨¡å‹
            const url = `https://generativelanguage.googleapis.com/v1beta/models/imagen-4.0-generate-001:predict?key=${apiKey}`;
            
            try {
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        instances: [{ prompt: prompt }], 
                        parameters: { sampleCount: 1 } 
                    })
                });
                
                if (!response.ok) {
                    const errText = await response.text();
                    throw new Error(`API Error: ${response.status} - ${errText}`);
                }
                
                const data = await response.json();
                if (data.predictions && data.predictions[0] && data.predictions[0].bytesBase64Encoded) {
                    return { success: true, imageUrl: `data:image/png;base64,${data.predictions[0].bytesBase64Encoded}` };
                }
                return { success: false, error: "API å›å‚³æ ¼å¼ä¸ç¬¦" };
            } catch (error) {
                console.error("Imagen AI Error:", error);
                return { success: false, error: error.message };
            }
        }

        function App() {
            const [targetContractAddress, setTargetContractAddress] = useState(DEFAULT_ADDRESS);
            const [account, setAccount] = useState(null);
            const [isOwner, setIsOwner] = useState(false);
            const [isConnecting, setIsConnecting] = useState(false);
            const [isMinting, setIsMinting] = useState(false);
            const [apiKey, setApiKey] = useState(DEFAULT_API_KEY);
            
            const [supply, setSupply] = useState(0);
            const [quantity, setQuantity] = useState(1);
            const [isSaleActive, setIsSaleActive] = useState(false);
            const [isRevealed, setIsRevealed] = useState(false);
            const [currentMintPrice, setCurrentMintPrice] = useState("0");

            // Admin Input State
            const [newMintPrice, setNewMintPrice] = useState("");
            const [newMaxBalance, setNewMaxBalance] = useState("");
            const [newMaxMint, setNewMaxMint] = useState("");
            const [newNotRevealedURI, setNewNotRevealedURI] = useState("");
            const [newBaseURI, setNewBaseURI] = useState("");
            const [inputAddress, setInputAddress] = useState(DEFAULT_ADDRESS);
            
            // AI Admin State
            const [generatedAdminImage, setGeneratedAdminImage] = useState(null);
            const [isGeneratingAdminImage, setIsGeneratingAdminImage] = useState(false);
            
            const [status, setStatus] = useState("");
            const [error, setError] = useState("");
            const [userNFTs, setUserNFTs] = useState([]);
            const [transferringId, setTransferringId] = useState(null);
            const [isAdminAction, setIsAdminAction] = useState(false);

            const accountRef = useRef(account);
            accountRef.current = account;
            const contractAddressRef = useRef(targetContractAddress);
            contractAddressRef.current = targetContractAddress;

            useEffect(() => {
                checkIfWalletIsConnected();
                if (window.ethereum) {
                    window.ethereum.on('accountsChanged', handleAccountsChanged);
                }
                const intervalId = setInterval(() => {
                    if (accountRef.current) {
                        fetchContractData(accountRef.current, contractAddressRef.current, true); 
                    }
                }, 30000);
                return () => {
                    if (window.ethereum) {
                        window.ethereum.removeListener('accountsChanged', handleAccountsChanged);
                    }
                    clearInterval(intervalId);
                };
            }, []);

            const handleAccountsChanged = (accounts) => {
                if (accounts.length > 0) {
                    setAccount(accounts[0]);
                    fetchContractData(accounts[0], targetContractAddress);
                } else {
                    disconnectWallet();
                }
            };

            const checkIfWalletIsConnected = async () => {
                if (window.location.protocol === 'file:') return;
                if (window.ethereum) {
                    try {
                        const provider = new ethers.BrowserProvider(window.ethereum);
                        const accounts = await provider.listAccounts();
                        if (accounts.length > 0) {
                            setAccount(accounts[0].address);
                            fetchContractData(accounts[0].address, targetContractAddress);
                        }
                    } catch (err) {
                        console.error(err);
                    }
                }
            };

            const connectWallet = async () => {
                if (window.location.protocol === 'file:') return setError("âš ï¸ è«‹ä½¿ç”¨ Local Server åŸ·è¡Œã€‚");
                if (typeof window.ethereum === 'undefined') return setError("æœªåµæ¸¬åˆ° MetaMaskã€‚");
                setIsConnecting(true);
                try {
                    const provider = new ethers.BrowserProvider(window.ethereum);
                    const accounts = await provider.send("eth_requestAccounts", []);
                    if (accounts && accounts.length > 0) {
                        setAccount(accounts[0]);
                        setError("");
                        setStatus("éŒ¢åŒ…é€£æ¥æˆåŠŸ ğŸŸ¢");
                        await fetchContractData(accounts[0], targetContractAddress);
                    }
                } catch (err) {
                    console.error(err);
                    setError("é€£æ¥å¤±æ•—");
                } finally {
                    setIsConnecting(false);
                }
            };

            const disconnectWallet = () => {
                setAccount(null);
                setIsOwner(false);
                setUserNFTs([]);
                setStatus("éŒ¢åŒ…å·²æ–·é–‹");
                setError("");
                setNewMintPrice("");
                setNewMaxBalance("");
                setNewMaxMint("");
                setNewNotRevealedURI("");
                setNewBaseURI("");
                setGeneratedAdminImage(null);
            };
            
            const handleUpdateContractAddress = () => {
                if(!ethers.isAddress(inputAddress)) return alert("ç„¡æ•ˆçš„åˆç´„åœ°å€");
                setTargetContractAddress(inputAddress);
                setStatus(`åˆç´„åœ°å€å·²æ›´æ–°ï¼Œé‡æ–°è®€å–ä¸­...`);
                setSupply(0);
                setIsOwner(false);
                setUserNFTs([]);
                if(account) {
                    fetchContractData(account, inputAddress);
                }
            };

            const fetchContractData = async (currentAccount, addressToFetch, isBackground = false) => {
                if (!window.ethereum || !addressToFetch) return;
                try {
                    const provider = new ethers.BrowserProvider(window.ethereum);
                    const contract = new ethers.Contract(addressToFetch, CONTRACT_ABI, provider);

                    const total = await contract.totalSupply();
                    const saleActive = await contract._isSaleActive();
                    const revealed = await contract._revealed();
                    const contractOwner = await contract.owner();
                    
                    const price = await contract.mintPrice();
                    const balanceLimit = await contract.maxBalance();
                    const mintLimit = await contract.maxMint();

                    setSupply(total.toString());
                    setIsSaleActive(saleActive);
                    setIsRevealed(revealed);
                    
                    const priceInEther = ethers.formatEther(price);
                    setCurrentMintPrice(priceInEther);

                    if (!isBackground) {
                        setNewMintPrice(priceInEther);
                        setNewMaxBalance(balanceLimit.toString());
                        setNewMaxMint(mintLimit.toString());
                        try {
                            const notRev = await contract.notRevealedUri();
                            setNewNotRevealedURI(notRev);
                        } catch (e) { console.log("Fetch notRevealedUri failed", e); }
                        try {
                            const base = await contract.baseURI(); 
                            setNewBaseURI(base);
                        } catch (e) { console.log("Fetch baseURI failed", e); }
                    }

                    if (currentAccount && contractOwner.toLowerCase() === currentAccount.toLowerCase()) {
                        setIsOwner(true);
                    } else {
                        setIsOwner(false);
                    }

                    if (!isBackground) {
                         if (!saleActive) setStatus("âš ï¸ è²©å”®æš«åœä¸­ (Paused)");
                         else setStatus("ğŸŸ¢ è²©å”®é€²è¡Œä¸­ (Active)");
                    } else {
                        if (!saleActive) setStatus("âš ï¸ è²©å”®æš«åœä¸­ (Paused)");
                        else if (status.includes("æš«åœ")) setStatus("ğŸŸ¢ è²©å”®é€²è¡Œä¸­ (Active)"); 
                    }

                    if (currentAccount) {
                        const ownedIds = [];
                        const maxSupply = 10;
                        for (let i = 1; i <= maxSupply; i++) {
                            try {
                                const owner = await contract.ownerOf(i);
                                if (owner.toLowerCase() === currentAccount.toLowerCase()) {
                                    ownedIds.push(i);
                                }
                            } catch (e) {}
                        }
                        setUserNFTs(ownedIds);
                    }

                } catch (err) {
                    console.error("æ•¸æ“šè®€å–éŒ¯èª¤:", err);
                    if(!isBackground) setStatus("ç„¡æ³•è®€å–åˆç´„æ•¸æ“š (è«‹æª¢æŸ¥åœ°å€)");
                }
            };

            // AI Function: Generate Admin Image
            const handleGenerateAdminImage = async () => {
                if (!apiKey) return alert("è«‹å…ˆè¨­å®š API Key");
                setIsGeneratingAdminImage(true);
                setGeneratedAdminImage(null);
                
                const prompt = "A high quality, cyberpunk style promotional image for a NFT project named NquMeta. Featuring a glowing mysterious blind box, neon lights, futuristic city background, digital art, 4k resolution.";
                
                const result = await callImagenAPI(apiKey, prompt);
                
                if (result.success) {
                    setGeneratedAdminImage(result.imageUrl);
                } else {
                    alert(`åœ–ç‰‡ç”Ÿæˆå¤±æ•—: ${result.error}`);
                }
                setIsGeneratingAdminImage(false);
            };

            // Admin Actions
            const toggleSale = async () => { /* ... existing toggleSale code ... */ 
                if (!isOwner) return;
                setIsAdminAction(true);
                try {
                    const provider = new ethers.BrowserProvider(window.ethereum);
                    const signer = await provider.getSigner();
                    const contract = new ethers.Contract(targetContractAddress, CONTRACT_ABI, signer);
                    const tx = await contract.flipSaleActive();
                    setStatus("æ­£åœ¨åˆ‡æ›è²©å”®ç‹€æ…‹...");
                    await tx.wait();
                    setStatus("âœ… è²©å”®ç‹€æ…‹å·²æ›´æ–°");
                    fetchContractData(account, targetContractAddress);
                } catch (err) { alert("æ“ä½œå¤±æ•—"); } finally { setIsAdminAction(false); }
            };
            const toggleReveal = async () => { /* ... existing toggleReveal code ... */ 
                if (!isOwner) return;
                if (!confirm("ç¢ºå®šè¦é–‹å•Ÿç›²ç›’å—ï¼Ÿé€™æ˜¯ä¸€å€‹å…¨åŸŸè¨­å®šï¼Œæ‰€æœ‰ NFT éƒ½å°‡è¢«æ­ç¤ºã€‚")) return;
                setIsAdminAction(true);
                try {
                    const provider = new ethers.BrowserProvider(window.ethereum);
                    const signer = await provider.getSigner();
                    const contract = new ethers.Contract(targetContractAddress, CONTRACT_ABI, signer);
                    const tx = await contract.flipReveal();
                    setStatus("æ­£åœ¨é–‹å•Ÿç›²ç›’...");
                    await tx.wait();
                    setStatus("âœ… ç›²ç›’å·²é–‹å•Ÿï¼");
                    fetchContractData(account, targetContractAddress);
                } catch (err) { alert("æ“ä½œå¤±æ•—"); } finally { setIsAdminAction(false); }
            };
            const handleUpdatePrice = async () => { /* ... */ 
                if (!newMintPrice) return alert("è«‹è¼¸å…¥åƒ¹æ ¼");
                setIsAdminAction(true);
                try {
                    const provider = new ethers.BrowserProvider(window.ethereum);
                    const signer = await provider.getSigner();
                    const contract = new ethers.Contract(targetContractAddress, CONTRACT_ABI, signer);
                    const priceInWei = ethers.parseEther(newMintPrice);
                    const tx = await contract.setMintPrice(priceInWei);
                    setStatus("æ›´æ–°åƒ¹æ ¼ä¸­...");
                    await tx.wait();
                    setStatus("âœ… åƒ¹æ ¼å·²æ›´æ–°");
                    fetchContractData(account, targetContractAddress);
                } catch (err) { alert("æ›´æ–°å¤±æ•—"); } finally { setIsAdminAction(false); }
            };
            const handleUpdateMaxBalance = async () => { /* ... */ 
                if (!newMaxBalance) return alert("è«‹è¼¸å…¥æ•¸é‡");
                setIsAdminAction(true);
                try {
                    const provider = new ethers.BrowserProvider(window.ethereum);
                    const signer = await provider.getSigner();
                    const contract = new ethers.Contract(targetContractAddress, CONTRACT_ABI, signer);
                    const tx = await contract.setMaxBalance(newMaxBalance);
                    setStatus("æ›´æ–°é™è³¼é‡ä¸­...");
                    await tx.wait();
                    setStatus("âœ… é™è³¼é‡å·²æ›´æ–°");
                    fetchContractData(account, targetContractAddress);
                } catch (err) { alert("æ›´æ–°å¤±æ•—"); } finally { setIsAdminAction(false); }
            };
            const handleUpdateMaxMint = async () => { /* ... */ 
                if (!newMaxMint) return alert("è«‹è¼¸å…¥æ•¸é‡");
                setIsAdminAction(true);
                try {
                    const provider = new ethers.BrowserProvider(window.ethereum);
                    const signer = await provider.getSigner();
                    const contract = new ethers.Contract(targetContractAddress, CONTRACT_ABI, signer);
                    const tx = await contract.setMaxMint(newMaxMint);
                    setStatus("æ›´æ–°å–®æ¬¡é™åˆ¶ä¸­...");
                    await tx.wait();
                    setStatus("âœ… å–®æ¬¡é™åˆ¶å·²æ›´æ–°");
                    fetchContractData(account, targetContractAddress);
                } catch (err) { alert("æ›´æ–°å¤±æ•—"); } finally { setIsAdminAction(false); }
            };
            const handleUpdateNotRevealedURI = async () => { /* ... */ 
                if (!newNotRevealedURI) return alert("è«‹è¼¸å…¥ URI");
                setIsAdminAction(true);
                try {
                    const provider = new ethers.BrowserProvider(window.ethereum);
                    const signer = await provider.getSigner();
                    const contract = new ethers.Contract(targetContractAddress, CONTRACT_ABI, signer);
                    const tx = await contract.setNotRevealedURI(newNotRevealedURI);
                    setStatus("æ›´æ–°ç›²ç›’åœ–ç‰‡ä¸­...");
                    await tx.wait();
                    setStatus("âœ… ç›²ç›’åœ–ç‰‡å·²æ›´æ–°");
                    fetchContractData(account, targetContractAddress);
                } catch (err) { console.error(err); alert("æ›´æ–°å¤±æ•—"); } finally { setIsAdminAction(false); }
            };
            const handleUpdateBaseURI = async () => { /* ... */ 
                if (!newBaseURI) return alert("è«‹è¼¸å…¥ URI");
                setIsAdminAction(true);
                try {
                    const provider = new ethers.BrowserProvider(window.ethereum);
                    const signer = await provider.getSigner();
                    const contract = new ethers.Contract(targetContractAddress, CONTRACT_ABI, signer);
                    const tx = await contract.setBaseURI(newBaseURI);
                    setStatus("æ›´æ–° Base URI ä¸­...");
                    await tx.wait();
                    setStatus("âœ… Base URI å·²æ›´æ–°");
                    fetchContractData(account, targetContractAddress);
                } catch (err) { console.error(err); alert("æ›´æ–°å¤±æ•—"); } finally { setIsAdminAction(false); }
            };

            const mintNFT = async () => {
                if (!account) return;
                setIsMinting(true);
                setError("");
                setStatus("ç­‰å¾…ç¢ºèªä¸­... ğŸ¦Š");
                try {
                    const provider = new ethers.BrowserProvider(window.ethereum);
                    const signer = await provider.getSigner();
                    const contract = new ethers.Contract(targetContractAddress, CONTRACT_ABI, signer);
                    const priceInWei = ethers.parseEther(currentMintPrice); 
                    const totalPrice = priceInWei * BigInt(quantity);
                    const tx = await contract.mintNquMeta(quantity, { value: totalPrice });
                    setStatus("äº¤æ˜“ç™¼é€æˆåŠŸï¼å€å¡Šç¢ºèªä¸­... ğŸ§±");
                    await tx.wait(1);
                    setStatus(`ğŸ‰ é‘„é€ æˆåŠŸï¼`);
                    fetchContractData(account, targetContractAddress);
                } catch (err) {
                    console.error(err);
                    setError(err.reason ? `åˆç´„éŒ¯èª¤: ${err.reason}` : "äº¤æ˜“å¤±æ•—");
                } finally { setIsMinting(false); }
            };

            const handleTransfer = async (tokenId, toAddress) => {
                if (!ethers.isAddress(toAddress)) return alert("ç„¡æ•ˆåœ°å€");
                if (!confirm(`ç¢ºå®šè½‰é€ #${tokenId} çµ¦ ${toAddress}?`)) return;
                setTransferringId(tokenId);
                try {
                    const provider = new ethers.BrowserProvider(window.ethereum);
                    const signer = await provider.getSigner();
                    const contract = new ethers.Contract(targetContractAddress, CONTRACT_ABI, signer);
                    const tx = await contract.safeTransferFrom(account, toAddress, tokenId);
                    setStatus("è½‰é€ä¸­...");
                    await tx.wait();
                    setStatus(`âœ… #${tokenId} è½‰é€æˆåŠŸ`);
                    fetchContractData(account, targetContractAddress);
                } catch (err) { alert("è½‰é€å¤±æ•—"); } finally { setTransferringId(null); }
            };

            return (
                <div className="app-container">
                    <div className="card">
                        <header>
                            <h1>ğŸ’NQU Meta - ç›²ç›’ NFT é‘„é€ å¹³å°</h1>
                            <p className="subtitle">ERC721A Gas Optimized Collection</p>
                        </header>

                        <div className="api-key-section">
                            <label className="api-key-label">ğŸ”‘ Google Gemini API Key (Required for AI features)</label>
                            <input 
                                type="password" 
                                className="api-key-input"
                                placeholder="Paste your API Key here..." 
                                value={apiKey} 
                                onChange={(e) => setApiKey(e.target.value)}
                            />
                        </div>

                        {account && isOwner && (
                            <div className="admin-panel">
                                <div className="admin-title">ğŸ”´ ç®¡ç†å“¡æ§åˆ¶å° (Admin Dashboard)</div>
                                
                                <div style={{marginBottom: "20px", paddingBottom: "15px", borderBottom: "1px solid rgba(255,255,255,0.1)"}}>
                                    <div className="admin-label" style={{marginBottom: "5px"}}>NFT åˆç´„åœ°å€</div>
                                    <div style={{display: "flex", gap: "10px"}}>
                                        <input 
                                            className="admin-input admin-input-full" 
                                            value={inputAddress} 
                                            onChange={(e) => setInputAddress(e.target.value)}
                                            placeholder="0x..."
                                        />
                                        <button className="admin-btn" onClick={handleUpdateContractAddress} disabled={isAdminAction}>æ›´æ–°åœ°å€</button>
                                    </div>
                                </div>
                                
                                <button className="toggle-btn" onClick={toggleSale} disabled={isAdminAction}>
                                    <span className={`status-indicator ${isSaleActive ? 'status-on' : 'status-off'}`}></span>
                                    {isSaleActive ? "é—œé–‰è²©å”® (Pause Sale)" : "é–‹å•Ÿè²©å”® (Start Sale)"}
                                </button>
                                
                                <button className="toggle-btn" onClick={toggleReveal} disabled={isAdminAction}>
                                    <span className={`status-indicator ${isRevealed ? 'status-on' : 'status-off'}`}></span>
                                    {isRevealed ? "éš±è—ç›²ç›’ (Hide Reveal)" : "é–‹å•Ÿç›²ç›’ (Reveal All)"}
                                </button>

                                <div className="admin-controls">
                                    <div className="admin-row">
                                        <div className="admin-label">é‘„é€ åƒ¹æ ¼ (ETH)</div>
                                        <input className="admin-input" placeholder="0.001" value={newMintPrice} onChange={(e) => setNewMintPrice(e.target.value)}/>
                                        <button className="admin-btn" onClick={handleUpdatePrice} disabled={isAdminAction}>æ›´æ–°</button>
                                    </div>
                                    <div className="admin-row">
                                        <div className="admin-label">éŒ¢åŒ…é™è³¼ (Max Balance)</div>
                                        <input className="admin-input" type="number" placeholder="5" value={newMaxBalance} onChange={(e) => setNewMaxBalance(e.target.value)}/>
                                        <button className="admin-btn" onClick={handleUpdateMaxBalance} disabled={isAdminAction}>æ›´æ–°</button>
                                    </div>
                                    <div className="admin-row">
                                        <div className="admin-label">å–®æ¬¡é™è³¼ (Max Mint)</div>
                                        <input className="admin-input" type="number" placeholder="3" value={newMaxMint} onChange={(e) => setNewMaxMint(e.target.value)}/>
                                        <button className="admin-btn" onClick={handleUpdateMaxMint} disabled={isAdminAction}>æ›´æ–°</button>
                                    </div>
                                    <div className="admin-row">
                                        <div className="admin-label">ç›²ç›’å°é¢åœ–ç‰‡ (Not Revealed URI)</div>
                                        <input className="admin-input admin-input-long" placeholder="ipfs://..." value={newNotRevealedURI} onChange={(e) => setNewNotRevealedURI(e.target.value)}/>
                                        <button className="admin-btn" onClick={handleUpdateNotRevealedURI} disabled={isAdminAction}>æ›´æ–°</button>
                                    </div>
                                    <div className="admin-row">
                                        <div className="admin-label">ç›²ç›’åœ–ç‰‡è·¯å¾‘ (Base URI)</div>
                                        <input className="admin-input admin-input-long" placeholder="ipfs://..." value={newBaseURI} onChange={(e) => setNewBaseURI(e.target.value)}/>
                                        <button className="admin-btn" onClick={handleUpdateBaseURI} disabled={isAdminAction}>æ›´æ–°</button>
                                    </div>
                                </div>

                                {/* AI Image Generation Feature */}
                                <div style={{marginTop: "20px", paddingTop: "15px", borderTop: "1px solid rgba(255,255,255,0.1)"}}>
                                    <div className="admin-label" style={{marginBottom: "5px"}}>âœ¨ AI å®£å‚³åœ–ç‰‡ç”Ÿæˆ</div>
                                    <button className="ai-btn" onClick={handleGenerateAdminImage} disabled={isGeneratingAdminImage}>
                                        {isGeneratingAdminImage ? "ç”Ÿæˆä¸­..." : "âœ¨ ç”Ÿæˆåœ–ç‰‡"}
                                    </button>
                                    {generatedAdminImage && (
                                        <div className="ai-result-box">
                                            <img src={generatedAdminImage} alt="Generated Admin Asset" />
                                        </div>
                                    )}
                                </div>
                            </div>
                        )}

                        {account && (
                            <div className="wallet-info-container">
                                <div className="wallet-badge badge-status"><span className="connection-dot"></span>å·²é€£æ¥</div>
                                <div className="wallet-badge badge-chain">Ethereum</div>
                                <div className="wallet-badge badge-address">{account.slice(0, 6)}...{account.slice(-4)}</div>
                                <div className="wallet-badge badge-disconnect" onClick={disconnectWallet} title="æ–·é–‹é€£æ¥">ğŸ”Œ æ–·é–‹</div>
                            </div>
                        )}

                        <div className="stats-container">
                            <div className="stat-box">
                                <span className="label">å·²é‘„é€ </span>
                                <span className="value">{supply} / 10</span>
                            </div>
                            <div className="stat-box">
                                <span className="label">åƒ¹æ ¼</span>
                                <span className="value">{currentMintPrice} ETH</span>
                            </div>
                        </div>

                        {!account ? (
                            <button className="connect-btn" onClick={connectWallet} disabled={isConnecting}>
                                {isConnecting ? "é€£æ¥ä¸­..." : "é€£æ¥éŒ¢åŒ…"}
                            </button>
                        ) : (
                            <div>
                                <div className="quantity-selector">
                                    <button onClick={() => setQuantity(Math.max(1, quantity - 1))} disabled={isMinting}>-</button>
                                    <span>{quantity}</span>
                                    <button onClick={() => setQuantity(Math.min(parseInt(currentMaxMint) || 5, quantity + 1))} disabled={isMinting}>+</button>
                                </div>
                                <button className="mint-btn" onClick={mintNFT} disabled={isMinting || !isSaleActive}>
                                    {isMinting ? "é‘„é€ ä¸­..." : (isSaleActive ? `ç«‹å³é‘„é€  ${quantity} å€‹` : "ç›®å‰ç„¡æ³•é‘„é€ ")}
                                </button>

                                {userNFTs.length > 0 && (
                                    <div>
                                        <h3 className="section-title">ğŸ–¼ï¸ æˆ‘çš„æ”¶è— ({userNFTs.length})</h3>
                                        <div className="nft-grid">
                                            {userNFTs.map(id => (
                                                <NFTCard 
                                                    key={id} 
                                                    tokenId={id} 
                                                    onTransfer={handleTransfer} 
                                                    isTransferring={transferringId === id}
                                                    isRevealed={isRevealed}
                                                    contractAddress={targetContractAddress}
                                                    apiKey={apiKey}
                                                />
                                            ))}
                                        </div>
                                    </div>
                                )}
                            </div>
                        )}

                        <div className="status-message">
                            {error && <p className="error-text">{error}</p>}
                            {status && <p className="info-text">{status}</p>}
                        </div>
                    </div>
                </div>
            );
        }

        // --- å­å…ƒä»¶ï¼šNFT å¡ç‰‡ ---
        function NFTCard({ tokenId, onTransfer, isTransferring, isRevealed, contractAddress, apiKey }) {
            const [toAddress, setToAddress] = useState("");
            const [metaImage, setMetaImage] = useState(null);
            const [loadingMeta, setLoadingMeta] = useState(false);
            
            // AI Backstory State
            const [backstory, setBackstory] = useState("");
            const [isGeneratingStory, setIsGeneratingStory] = useState(false);

            useEffect(() => {
                fetchMetadata();
            }, [isRevealed, tokenId, contractAddress]);

            const fetchMetadata = async () => {
                setLoadingMeta(true);
                try {
                    const provider = new ethers.BrowserProvider(window.ethereum);
                    const contract = new ethers.Contract(contractAddress, CONTRACT_ABI, provider);
                    const uri = await contract.tokenURI(tokenId);
                    if (uri) {
                        let httpUri = uri;
                        if (uri.startsWith("ipfs://")) {
                            httpUri = uri.replace("ipfs://", "https://ipfs.io/ipfs/");
                        }
                        const response = await fetch(httpUri);
                        const metadata = await response.json();
                        if (metadata.image) {
                            let imgUrl = metadata.image;
                            if (imgUrl.startsWith("ipfs://")) {
                                imgUrl = imgUrl.replace("ipfs://", "https://ipfs.io/ipfs/");
                            }
                            setMetaImage(imgUrl);
                        }
                    }
                } catch (err) { console.error("Metadata error:", err); setMetaImage(null); } finally { setLoadingMeta(false); }
            };

            const handleGenerateStory = async () => {
                setIsGeneratingStory(true);
                const prompt = `ä½ æ˜¯ NquMeta å…ƒå®‡å®™çš„èªªæ›¸äººã€‚è«‹ç‚º NquMeta NFT #${tokenId} å‰µä½œä¸€å€‹ç°¡çŸ­ï¼ˆ50å­—ä»¥å…§ï¼‰ã€ç¥ç§˜ä¸”å¸¶æœ‰ Cyberpunk é¢¨æ ¼çš„è§’è‰²èƒŒæ™¯æ•…äº‹ã€‚å¦‚æœé€™å¼µå¡ç‰‡å°šæœªè§£ç›²ï¼Œè«‹æè¿°å®ƒæ•£ç™¼å‡ºçš„ç¥ç§˜èƒ½é‡ã€‚è«‹ç”¨ç¹é«”ä¸­æ–‡å›ç­”ã€‚`;
                const story = await callGeminiAPI(apiKey, prompt);
                setBackstory(story);
                setIsGeneratingStory(false);
            };

            return (
                <div className="nft-card">
                    <div className="nft-image-box">
                        {loadingMeta ? (
                            <span style={{fontSize: "0.8rem", color: "#64748b"}}>Loading...</span>
                        ) : (
                            metaImage ? (
                                <img src={metaImage} className="nft-image" alt={`NFT #${tokenId}`} onError={(e) => {e.target.style.display='none';}} />
                            ) : (
                                <span className="nft-placeholder">{isRevealed ? "ğŸ–¼ï¸" : "ğŸ"}</span>
                            )
                        )}
                    </div>
                    
                    <span className="nft-id">#{tokenId}</span>
                    <span style={{fontSize: "0.75rem", color: "#64748b", marginBottom: "8px"}}>
                        {isRevealed ? "å·²é–‹å•Ÿ" : "æœªé–‹å•Ÿ"}
                    </span>
                    
                    {/* AI Backstory Button */}
                    <button className="ai-btn" onClick={handleGenerateStory} disabled={isGeneratingStory}>
                        {isGeneratingStory ? "âœ¨ ç”Ÿæˆä¸­..." : "âœ¨ ç”Ÿæˆæ•…äº‹"}
                    </button>
                    {backstory && (
                        <div className="ai-result-box" style={{marginTop: "5px", marginBottom: "10px"}}>
                            <p>{backstory}</p>
                        </div>
                    )}

                    <input type="text" placeholder="æ¥æ”¶åœ°å€ 0x..." className="transfer-input" value={toAddress} onChange={(e) => setToAddress(e.target.value)} disabled={isTransferring} style={{marginTop: "5px"}}/>
                    <button className="transfer-btn" disabled={isTransferring || !toAddress} onClick={() => onTransfer(tokenId, toAddress)}>{isTransferring ? "..." : "è½‰è´ˆ"}</button>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
